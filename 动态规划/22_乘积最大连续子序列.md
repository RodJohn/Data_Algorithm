       
                            

# 乘积最大连续子序列
    
    https://leetcode-cn.com/problems/maximum-product-subarray/
    

# 题目

    给定一个整数数组 nums ，
    找出一个序列中乘积最大的连续子序列
    （该序列至少包含一个数）。

    示例 1:
    输入: [2,3,-2,4]
    输出: 6
    解释: 子数组 [2,3] 有最大乘积 6。
    
    示例 2:
    输入: [-2,0,-1]
    输出: 0
    解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。


# 分析

    整数数组
    连续子序列
    乘积最大
    
    某点的最大乘积
    
        该点为负 前一点最大乘积为负
        该点为正 前一点最大乘积为正
        该点为0 
        前一点为0 为本身或者0

    前一个点乘积为0
        第二个点
            最大  为本身  重新开始计算
            最小  为本身
    前一个点乘积为正
        第二个点
            最大  正正
            最小  正负
              
        
便于理解

    https://blog.csdn.net/qq_41231926/article/details/86261978
    
        
# 实现

    
    






    public class Solution {
        public int maxProduct(int[] nums) {
            int[] maxdp = new int[nums.length];
            int[] mindp = new int[nums.length];
            maxdp[0] = mindp[0] = nums[0];
            for(int i = 1; i < nums.length; i++){
                if(nums[i] >= 0){
                    maxdp[i] = Math.max(maxdp[i - 1] * nums[i], nums[i]);
                    mindp[i] = Math.min(mindp[i - 1] * nums[i], nums[i]);
                }else{
                    maxdp[i] = Math.max(mindp[i - 1] * nums[i], nums[i]);
                    mindp[i] = Math.min(maxdp[i - 1] * nums[i], nums[i]);
                }
            }
            int result = Integer.MIN_VALUE;
            for(int i = 0; i < maxdp.length ; i++){
                if(maxdp[i] > result){
                    result = maxdp[i];
                }
            }
            return result;
        }
    }
    
    

# 优化

    class Solution {
        public int maxProduct(int[] nums) {
            int max = Integer.MIN_VALUE, imax = 1, imin = 1;
            for(int i=0; i<nums.length; i++){
                if(nums[i] < 0){ 
                  int tmp = imax;
                  imax = imin;
                  imin = tmp;
                }
                imax = Math.max(imax*nums[i], nums[i]);
                imin = Math.min(imin*nums[i], nums[i]);
                
                max = Math.max(max, imax);
            }
            return max;
        }
    }
  