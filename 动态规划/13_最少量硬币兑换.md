# 硬币找零

    https://leetcode-cn.com/problems/coin-change/

# 参考

    https://www.cnblogs.com/grandyang/p/5138186.html

# 题目

    给定不同面额的硬币 coins 和一个总金额 amount。
    编写一个函数来计算可以凑成总金额所需的最少的硬币个数。
    如果没有任何一种硬币组合能组成总金额，返回 -1。

    示例 1:
    输入: coins = [1, 2, 5], amount = 11
    输出: 3 
    解释: 11 = 5 + 5 + 1
    
    示例 2:
    输入: coins = [2], amount = 3
    输出: -1

# 分析

    总额为n时的最少硬币个数
    可以通过 n-面值（多个） 中的最小值加一


# 实现

    状态
        用一维数组dp，
        dp[i]表示钱数为i时的最小硬币数的找零，
    状态转移方程
        for(int j =0 ;j < coins.length ;j++){
            dp[i] = min(dp[i], dp[i - coins[j]] + 1);
        }
    初始值
        dp[0] = 0;
    优化
        不能省略一维数组
        
代码

    import java.math.*;
    import java.util.*;
    class Solution {
        public int coinChange(int[] coins, int n) {        
            int[] dp = new int[n+1];
            int max = n+1;
            Arrays.fill(dp,max);
            dp[0] = 0;
            for(int i = 1 ;i<dp.length;i++){
                for(int j =0 ;j < coins.length ;j++){
                    if(i>=coins[j]){
                        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                    }                    
                }
            }
            return dp[n]==max?-1:dp[n];
        }
    }

    
    
    


