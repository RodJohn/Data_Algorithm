# 最长上升子序列

    https://leetcode-cn.com/problems/longest-increasing-subsequence/
    https://www.nowcoder.com/practice/d83721575bd4418eae76c916483493de
    
# 题目    

    给定一个无序的整数数组，
    找到其中最长上升子序列的长度。

    示例:
    输入: [10,9,2,5,3,7,101,18]
    输出: 4 
    解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。


    说明:
    可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
    你算法的时间复杂度应该为 O(n^2) 。
    进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?
    
# 分析

    遍历数组
    当前点的最长上升子序列
    遍历前面的全部点
    如果该点大于前面的某一点
        则为那一点的值加一
    否则为1


# 实现

    状态表达式
        dp[i] 第i点的最长计数
    状态转移方程
        dp[i] =         


    import java.util.*;
    import java.math.*;
    class Solution {
        public int lengthOfLIS(int[] nums) {
            if(nums.length==0){
                return 0;
            }
            int[] dp = new int[nums.length];
            int rs = 1;
            dp[0] = 1;         
            for(int i = 1; i < nums.length ; i++){
                int maxPre = 0;
                for(int j = 0 ; j<i ; j++){
                   if(nums[i]>nums[j]){
                       maxPre = Math.max(dp[j] ,maxPre);
                   } 
                   dp[i] = maxPre+1;
                   rs = Math.max(dp[i] ,rs);
                }
            }
            return rs;
        }
    }
