       
                            

# 最长上升子序列


# Coin Change 硬币找零

示例

    Example 1:
    coins = [1, 2, 5], amount = 11
    return 3 (11 = 5 + 5 + 1)
    
    Example 2:
    coins = [2], amount = 3
    return -1.

    求极值问题，我们还是主要考虑动态规划Dynamic Programming来做
    好处是保留了一些中间状态的计算值，这样可以避免大量的重复计算

    状态
    维护一个一维动态数组dp，其中dp[i]表示钱数为i时的最小硬币数的找零，

    状态转移方程
    
    假设我取了一个值为5的硬币，那么由于目标值是11，
    所以是不是假如我们知道dp[6]，
    那么就知道了组成11的dp值了？
    所以我们更新dp[i]的方法就是遍历每个硬币，
    如果遍历到的硬币值小于i值（比如我们不能用值为5的硬币去更新dp[3]）时，
    我们用 dp[i - coins[j]] + 1 来更新dp[i]，所以状态转移方程为：
    
    dp[i] = min(dp[i], dp[i - coins[j]] + 1);
    
    也可以用上楼的方法来推  一个是sum 一个是min


    初始值
    dp[0] = 0;
    
代码

    class Solution {
    public:
        int coinChange(vector<int>& coins, int amount) {
            vector<int> dp(amount + 1, amount + 1);
            dp[0] = 0;
            for (int i = 1; i <= amount; ++i) {
                for (int j = 0; j < coins.size(); ++j) {
                    if (coins[j] <= i) {
                        dp[i] = min(dp[i], dp[i - coins[j]] + 1);
                    }
                }
            }
            return (dp[amount] > amount) ? -1 : dp[amount];
        }
    };
    
    
    https://www.cnblogs.com/grandyang/p/5138186.html

# LeetCode152——乘积最大子序列

整数数组 正 负 0 

难




便于理解

    https://blog.csdn.net/qq_41231926/article/details/86261978
    


代码


    public class Solution {
        public int maxProduct(int[] nums) {
            int[] maxdp = new int[nums.length];
            int[] mindp = new int[nums.length];
            maxdp[0] = mindp[0] = nums[0];
            for(int i = 1; i < nums.length; i++){
                if(nums[i] >= 0){
                    maxdp[i] = Math.max(maxdp[i - 1] * nums[i], nums[i]);
                    mindp[i] = Math.min(mindp[i - 1] * nums[i], nums[i]);
                }else{
                    maxdp[i] = Math.max(mindp[i - 1] * nums[i], nums[i]);
                    mindp[i] = Math.min(maxdp[i - 1] * nums[i], nums[i]);
                }
            }
            int result = Integer.MIN_VALUE;
            for(int i = 0; i < maxdp.length ; i++){
                if(maxdp[i] > result){
                    result = maxdp[i];
                }
            }
            return result;
        }
    }
    
    
# 股票买卖

    121 122 123 309 188 714 
    