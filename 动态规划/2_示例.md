
# 爬楼梯

    https://leetcode-cn.com/problems/climbing-stairs
    https://www.nowcoder.com/practice/b178fcef3ed4448c99d7c0297312212d

# 题目

    假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
    每次你可以爬 1 或 2 个台阶。
    你有多少种不同的方法可以爬到楼顶呢？
    注意：给定 n 是一个正整数。

示例

    2 阶到楼顶。
    1.  1 阶 + 1 阶
    2.  2 阶
    
    3 阶到楼顶。
    1.  1 阶 + 1 阶 + 1 阶
    2.  1 阶 + 2 阶
    3.  2 阶 + 1 阶

# 分析

    求有多少种方法
    第n阶可以由第n-1阶和第n-2阶爬上来
    方法数相当于前两者数量之和
    所以是个动态规划的问题

# 实现
 
dp推导
    
    /*
        状态表达式：
            dp[i] 
            到达n阶的所有方式
        状态变换表达式：
            dp[i] = dp[i-1] + dp[i-2]
        示例值:
            1 2 3 
        递推初始值：
            dp[0] = 1    
            dp[1] = 1
            dp[2] = 2                
    */

实现

    class Solution {
        public int climbStairs(int n) {
            int[] dp = new int [n+1];
            dp[0] = 1;
            dp[1] = 1;
            for(int i = 2;i<=n;i++){
                dp[i] = dp[i-1] + dp[i-2];
            }
            return dp[n];
        }
    }

# 优化

思路

    优化递推状态的保存
    由于最后只需一个值
    完全可以使用一个变量保存

实现

    class Solution {
        public int climbStairs(int n) {
            int a = 1;
            int b = 1;
            int rs = b;
            for(int i = 2 ; i<=n;i++){
                int rs = a + b;
                a = b;
                b = rs;
            }
            return rs;
        }
    }    


# 完整

    java要导包
    要注意数据类型
    
    import java.util.*;
    import java.math.BigInteger;
    public class Main {
       
      public static void main(String[] args){
          Scanner sc = new Scanner(System.in);
          int n = sc.nextInt();
          System.out.println(climbStair(n));
      }
      
      public static BigInteger climbStair(int n){
          BigInteger a = new BigInteger("1");
          BigInteger b = new BigInteger("1");
          BigInteger rs = b;
          for(int i = 2 ;i <= n;i++){
              rs = a.add(b);
              a = b;
              b = rs; 
          }
          return rs;
      }
    }


